{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./lib/es6-menu-aim.ts","webpack:///./lib/es6-menu-aim-types.ts"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_mouseLocs","_instanceCounter","MenuAim","menu","opts","activeRow","lastDelayLoc","timeoutId","exitTimeoutID","options","nestedElementArr","noop","this","rowSelector","exitDelay","submenuSelector","submenuDirection","MenuDirection","right","tolerance","isRoot","enter","exit","activate","deactivate","exitMenu","clickRow","mouseenterRow","mouseleaveRow","mouseleaveMenu","commitExit","attach","Array","from","parentNode","querySelectorAll","classList","forEach","el","addEventListener","document","_mousemoveDocument","ev","clearTimeout","setTimeout","currentTarget","possiblyActivate","row","newRow","delay","activationDelay","self","activeRowFound","rows","parentElement","maxI","length","offset","_offset","upperLeft","x","left","y","top","upperRight","offsetWidth","lowerLeft","offsetHeight","lowerRight","loc","prevLoc","decreasingCorner","increasingCorner","below","above","decreasingSlope","_calcSlope","increasingSlope","prevDecreasingSlope","prevIncreasingSlope","li","push","removeEventListener","pageX","pageY","shift","b","elem","rect","getBoundingClientRect","win","ownerDocument","defaultView","pageYOffset","pageXOffset"],"mappings":"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","file":"es6-menu-aim.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { Coordinates, MenuDirection, EventHandler, Options, ElementOffset } from './es6-menu-aim-types';\r\n\r\nconst MOUSE_LOCS_TRACKED:number = 3,  // number of past mouse locations to track\r\n    DELAY:number = 300;  // ms delay when user appears to be entering submenu\r\n\r\n// all instances of this class should use the same mouse-move event listener\r\nlet _mouseLocs:Array<Coordinates> = [],\r\n    // counting instances ... this is used to detect if\r\n    // `_mousemoveDocument` should be unregistered\r\n    _instanceCounter = 0;\r\n\r\n/**\r\n * Main class of MenuAim\r\n */\r\nclass MenuAim {\r\n    activeRow:HTMLElement = null;\r\n    lastDelayLoc:Coordinates = null;\r\n    timeoutId:NodeJS.Timeout = null;\r\n    exitTimeoutID:NodeJS.Timeout = null;\r\n    options:Options = null;\r\n    menu:HTMLElement = null;\r\n    nestedElementArr:HTMLElement[] = [];\r\n\r\n    /**\r\n     * Constructor function\r\n     * @param menu root menu HTML element\r\n     * @param opts (optional) config options (see [Options](#options))\r\n     */\r\n    constructor(menu:HTMLElement, opts?:Options) {\r\n\r\n        /**\r\n         * Dummy function which is used as default value for event listeners\r\n         */\r\n        const noop = () => {};\r\n\r\n        opts = opts || {};\r\n\r\n        // setting the default values\r\n        this.options = {\r\n            rowSelector: opts.rowSelector || \"> li\",\r\n            exitDelay: opts.exitDelay || null,\r\n            submenuSelector: opts.submenuSelector || \"*\",\r\n            submenuDirection: opts.submenuDirection || MenuDirection.right,\r\n            tolerance: opts.tolerance || 75,\r\n            isRoot: opts.isRoot || true,\r\n            enter: opts.enter || noop,\r\n            exit: opts.exit || noop,\r\n            activate: opts.activate || noop,\r\n            deactivate: opts.deactivate || noop,\r\n            exitMenu: opts.exitMenu || noop,\r\n            clickRow: opts.clickRow || noop\r\n        };\r\n\r\n        // binding event handlers\r\n        this.mouseenterRow = this.mouseenterRow.bind(this);\r\n        this.mouseleaveRow = this.mouseleaveRow.bind(this);\r\n        this.clickRow = this.clickRow.bind(this);\r\n        this.mouseleaveMenu = this.mouseleaveMenu.bind(this);\r\n        this.commitExit = this.commitExit.bind(this);\r\n\r\n        // attaching event listeners\r\n        this.attach(menu);\r\n    }\r\n\r\n    /**\r\n     * This method is called initially and each time a menu is re-activated\r\n     */\r\n    attach(menu:HTMLElement):void {\r\n\r\n        this.menu = menu;\r\n\r\n        // attach event listener to rows\r\n        this.nestedElementArr = Array.from(this.menu.parentNode.querySelectorAll(`.${this.menu.classList[0]} ${this.options.rowSelector}`));\r\n        this.nestedElementArr.forEach((el: HTMLElement) => {\r\n            el.addEventListener('mousemove', this.mouseenterRow);\r\n        })\r\n\r\n        if(this.options.isRoot) {\r\n        // only the ROOT instance should be registering the `menuExit`\r\n        // event ... all the contained child instances will be hidden by the root instance\r\n            this.menu.addEventListener('mouseleave', this.mouseleaveMenu);\r\n        }\r\n\r\n        if(++_instanceCounter===1) {\r\n        // IF this is the first instance\r\n        // > register the single mouse move event handler - only one is needed\r\n            document.addEventListener('mousemove', _mousemoveDocument);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancel possible row activations when leaving the menu entirely\r\n     * @param ev Mouse Event\r\n     */\r\n    mouseleaveMenu(ev:Event):void {\r\n\r\n        if (this.timeoutId) {\r\n            clearTimeout(this.timeoutId);\r\n            this.timeoutId = null;\r\n        }\r\n\r\n        if(this.options.exitDelay) {\r\n\r\n            if(this.exitTimeoutID) {\r\n            // IF the scheduling timer already exists -> clear it\r\n\r\n                clearTimeout(this.exitTimeoutID);\r\n                this.exitTimeoutID = null;\r\n            }\r\n\r\n            this.exitTimeoutID = setTimeout(this.commitExit, this.options.exitDelay);\r\n\r\n        } else {\r\n            this.commitExit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides all the sub-menus and the menu. It can be called externally\r\n     */\r\n    forceExit():void {\r\n\r\n        // clear the exit timeout ... if it's set\r\n        if(this.exitTimeoutID) {\r\n            clearTimeout(this.exitTimeoutID);\r\n        }\r\n\r\n        this.commitExit();\r\n\r\n    }\r\n\r\n    /**\r\n     * Closes the menu\r\n     */\r\n    commitExit():void {\r\n\r\n        this.timeoutId = this.exitTimeoutID = null;\r\n\r\n        // IF exitMenu is supplied and returns true, deactivate the\r\n        // currently active row on menu exit.\r\n        if (this.options.exitMenu(this)) {\r\n            if (this.activeRow) {\r\n                this.options.deactivate(this.activeRow);\r\n            }\r\n\r\n            this.activeRow = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger a possible row activation whenever entering a new row.\r\n     * @param ev Mouse event\r\n     */\r\n    mouseenterRow(ev:MouseEvent):void {\r\n\r\n        if(this.exitTimeoutID) {\r\n            clearTimeout(this.exitTimeoutID);\r\n            this.exitTimeoutID = null;\r\n        }\r\n\r\n        if (this.timeoutId) {\r\n            // Cancel any previous activation delays\r\n            clearTimeout(this.timeoutId);\r\n            this.timeoutId = null;\r\n        }\r\n\r\n        this.options.enter(ev.currentTarget);\r\n\r\n        this.possiblyActivate(<HTMLElement>ev.currentTarget);\r\n    }\r\n\r\n\r\n    mouseleaveRow(ev:MouseEvent):void {\r\n        this.options.exit(ev.currentTarget);\r\n    }\r\n\r\n    /**\r\n     * Immediately activate a row if the user clicks on it.\r\n     * @param ev Mouse Event\r\n     */\r\n    clickRow(ev:MouseEvent):void {\r\n        \r\n        if(ev.currentTarget !== this.activeRow) {\r\n            this.activate(<HTMLElement>ev.currentTarget);\r\n        }\r\n\r\n        this.options.clickRow(ev, ev.currentTarget); // pozovi registrirani event handler\r\n    }\r\n\r\n    /**\r\n     * Activate a menu row.\r\n     * @param row menu row which should be activated\r\n     */\r\n    activate(row:HTMLElement):void {\r\n\r\n        if (row == this.activeRow) {\r\n            return;\r\n        }\r\n\r\n        if (this.activeRow) {\r\n            this.options.deactivate(this.activeRow);\r\n        }\r\n\r\n        var newRow = this.options.activate(row);\r\n\r\n        if(newRow) {\r\n            this.activeRow = newRow;\r\n        } else {\r\n            this.activeRow = row;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Possibly activate a menu row. If mouse movement indicates that we\r\n     * shouldn't activate yet because user may be trying to enter\r\n     * a submenu's content, then delay and check again later.\r\n     * \r\n     * @param row menu row to be activated\r\n     */\r\n    possiblyActivate(row:HTMLElement):void {\r\n\r\n        let delay = this.activationDelay();\r\n        let self = this;\r\n\r\n        if (delay) {\r\n            this.timeoutId = setTimeout(() => {  self.possiblyActivate(row); }, delay);\r\n        } else {\r\n            this.activate(row);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the amount of time that should be used as a delay before the\r\n     * currently hovered row is activated.\r\n     *\r\n     * Returns 0 if the activation should happen immediately. Otherwise,\r\n     * returns the number of milliseconds that should be delayed before\r\n     * checking again to see if the row should be activated.\r\n     */\r\n    activationDelay():number {\r\n\r\n        let activeRowFound:boolean = false;\r\n\r\n        if (this.activeRow) {\r\n        // IF active row is set\r\n        // > check to see if it's of correct type\r\n            let rows:NodeListOf<HTMLElement> = this.activeRow.parentElement.querySelectorAll(this.options.submenuSelector);\r\n    \r\n            for(let i=0,maxI=rows.length; i<maxI; i++) {\r\n                if(rows[i] === this.activeRow) {\r\n                    activeRowFound=true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!activeRowFound) {\r\n        // IF there is no other submenu row already active, then\r\n        // go ahead and activate immediately.\r\n            return 0;\r\n        }\r\n\r\n        var offset = _offset(this.menu),\r\n            upperLeft = {\r\n                x: offset.left,\r\n                y: offset.top - this.options.tolerance\r\n            },\r\n            upperRight = {\r\n                x: offset.left + this.menu.offsetWidth,\r\n                y: upperLeft.y\r\n            },\r\n            lowerLeft = {\r\n                x: offset.left,\r\n                y: offset.top + this.menu.offsetHeight + this.options.tolerance\r\n            },\r\n            lowerRight = {\r\n                x: offset.left + this.menu.offsetWidth,\r\n                y: lowerLeft.y\r\n            },\r\n            loc = _mouseLocs[_mouseLocs.length - 1],\r\n            prevLoc = _mouseLocs[0];\r\n\r\n        if (!loc) {\r\n            return 0;\r\n        }\r\n\r\n        if (!prevLoc) {\r\n            prevLoc = loc;\r\n        }\r\n\r\n        if (prevLoc.x < offset.left || prevLoc.x > lowerRight.x ||\r\n            prevLoc.y < offset.top || prevLoc.y > lowerRight.y) {\r\n            // If the previous mouse location was outside of the entire\r\n            // menu's bounds, immediately activate.\r\n            return 0;\r\n        }\r\n\r\n        if (this.lastDelayLoc &&\r\n                loc.x == this.lastDelayLoc.x && loc.y == this.lastDelayLoc.y) {\r\n            // If the mouse hasn't moved since the last time we checked\r\n            // for activation status, immediately activate.\r\n            return 0;\r\n        }\r\n\r\n        var decreasingCorner = upperRight,\r\n            increasingCorner = lowerRight;\r\n\r\n        // Our expectations for decreasing or increasing slope values\r\n        // depends on which direction the submenu opens relative to the\r\n        // main menu. By default, if the menu opens on the **right**, we\r\n        // expect the slope between the cursor and the upper right\r\n        // corner to decrease over time, as explained above. If the\r\n        // submenu opens in a different direction, we change our slope\r\n        // expectations.\r\n        if (this.options.submenuDirection == MenuDirection.left) {\r\n            decreasingCorner = lowerLeft;\r\n            increasingCorner = upperLeft;\r\n        } else if (this.options.submenuDirection == MenuDirection.below) {\r\n            decreasingCorner = lowerRight;\r\n            increasingCorner = lowerLeft;\r\n        } else if (this.options.submenuDirection == MenuDirection.above) {\r\n            decreasingCorner = upperLeft;\r\n            increasingCorner = upperRight;\r\n        }\r\n\r\n        var decreasingSlope = _calcSlope(loc, decreasingCorner),\r\n            increasingSlope = _calcSlope(loc, increasingCorner),\r\n            prevDecreasingSlope = _calcSlope(prevLoc, decreasingCorner),\r\n            prevIncreasingSlope = _calcSlope(prevLoc, increasingCorner);\r\n\r\n        if (decreasingSlope < prevDecreasingSlope &&\r\n                increasingSlope > prevIncreasingSlope) {\r\n            // Mouse is moving from previous location towards the\r\n            // currently activated submenu. Delay before activating a\r\n            // new menu row, because user may be moving into submenu.\r\n            this.lastDelayLoc = loc;\r\n            return DELAY;\r\n        }\r\n\r\n        this.lastDelayLoc = null;\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Hook up menu item events. This method allows menu\r\n     * items to be added externaly\r\n     */\r\n    hookUp(li:HTMLElement):void {\r\n        this.nestedElementArr.push(li);\r\n        li.addEventListener('mouseenter', this.mouseenterRow);\r\n        li.addEventListener('mouseleave', this.mouseleaveRow);\r\n        li.addEventListener('click', this.clickRow);\r\n    }\r\n\r\n    /**\r\n     * Sets a DOM node as currently active menu item.\r\n     * This is to be used form external code in case\r\n     * menu item list can dynamically change\r\n     * @param row DOM node to be set active\r\n     */\r\n    setActiveRow(row:HTMLElement):void {\r\n\r\n        this.activeRow = row;\r\n\r\n        if(this.timeoutId) {\r\n        // AKO već postoji schedulirani timeout -> resetiraj ga\r\n            // console.log('schedule Exit CLEAR');\r\n\r\n            window.clearTimeout(this.timeoutId);\r\n            this.timeoutId = null;\r\n        }\r\n\r\n        if(this.exitTimeoutID) {\r\n        // AKO već postoji schedulirani timeout -> resetiraj ga\r\n            // console.log('schedule Exit CLEAR');\r\n\r\n            window.clearTimeout(this.exitTimeoutID);\r\n            this.exitTimeoutID = null;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Deactivate menu item which is currently marked as active\r\n     */\r\n    deactivateRow():void {\r\n\r\n        if(this.activeRow) {\r\n            this.options.deactivate(this.activeRow);\r\n        }\r\n\r\n        this.activeRow = null;\r\n    }\r\n\r\n    /**\r\n     * Detaches MenuAim from DOM containser ... to be used\r\n     * while disposing the menu\r\n     */\r\n    detach():void {\r\n        // preventing multiple calls\r\n        if(!this.menu) {\r\n            return;\r\n        }\r\n\r\n        if (this.timeoutId) {\r\n            clearTimeout(this.timeoutId);\r\n        }\r\n\r\n        // detach rows handlers\r\n        this.nestedElementArr.forEach((el:HTMLElement) => {\r\n            el.removeEventListener('mousemove', this.mouseenterRow);\r\n        })\r\n\r\n        if(--_instanceCounter===0) {\r\n        // IF this was the last existing instance of the class\r\n        // > stop tracking the mouse cusros\r\n            document.removeEventListener('mousemove', _mousemoveDocument);\r\n        }\r\n\r\n        if(this.options.isRoot) {\r\n            this.menu.removeEventListener('mouseleave', this.mouseleaveMenu)\r\n        }\r\n\r\n        this.timeoutId = this.lastDelayLoc = this.activeRow = this.menu = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Event handler which keep track of the last few locations of the mouse.\r\n * @param ev mouse event\r\n * @private\r\n */\r\nconst _mousemoveDocument = (ev:MouseEvent):void => {\r\n    \r\n    _mouseLocs.push({x: ev.pageX, y: ev.pageY});\r\n\r\n    if (_mouseLocs.length > MOUSE_LOCS_TRACKED) {\r\n        _mouseLocs.shift();\r\n    }\r\n}\r\n\r\n/**\r\n * Detect if the user is moving towards the currently activated\r\n * submenu.\r\n * If the mouse is heading relatively clearly towards\r\n * the content of submenu, we should wait and give the user more\r\n * time before activating a new row. If the mouse is heading\r\n * elsewhere, we can immediately activate a new row.\r\n * We detect this by calculating the slope formed between the\r\n * current mouse location and the upper/lower right points of\r\n * the menu. We do the same for the previous mouse location.\r\n * If the current mouse location's slopes are\r\n * increasing/decreasing appropriately compared to the\r\n * previous, we know the user is moving toward the submenu.\r\n * Note that since the y-axis increases as the cursor moves\r\n * down the screen, we are looking for the slope between the\r\n * cursor and the upper right corner to decrease over time, not\r\n * increase (somewhat counterintuitively).\r\n * @param a \r\n * @param b \r\n * @private\r\n */\r\nconst _calcSlope = (a:Coordinates, b:Coordinates):number => {\r\n    return ((b.y - a.y) / (b.x - a.x));\r\n}\r\n\r\n/**\r\n * Returns coordinates of the given element relative to the window\r\n * @param elem DOM element who's coordinates need to be calculated\r\n * @private\r\n */\r\nconst _offset = (elem:HTMLElement):ElementOffset => {\r\n\r\n    let rect:ClientRect = elem.getBoundingClientRect(),\r\n        win:Window = elem.ownerDocument.defaultView;\r\n\r\n    return({\r\n        top: rect.top + win.pageYOffset,\r\n        left: rect.left + win.pageXOffset\r\n    });\r\n}\r\n\r\nexport { Coordinates, EventHandler, Options, MenuAim }; ","type Coordinates = {\r\n    x:number,\r\n    y:number\r\n};\r\n\r\ntype ElementOffset = {\r\n    top:number,\r\n    left:number\r\n};\r\n\r\nenum MenuDirection {\r\n    left = \"left\",\r\n    right = \"right\",\r\n    below = \"below\",\r\n    above = \"above\"\r\n}\r\n\r\ntype EventHandler = (data:any, target?:any) => any;\r\n\r\ntype Options = {\r\n    /** Function to call when a row is purposefully activated.\r\n     *  Use this to show a submenu's content for the activated row.*/ \r\n    activate?: EventHandler,\r\n    /** Function to call when a row is deactivated */\r\n    deactivate?: EventHandler,\r\n    /** Function to call when mouse enters a menu row.\r\n     *  Entering a row does not mean the row has been\r\n     *  activated, as the user may be mousing over to a submenu. */\r\n    enter?: EventHandler,\r\n    /** Function to call when mouse exits a menu row. */\r\n    exit?: EventHandler,\r\n    /** Function to call when mouse exits the entire menu. If this\r\n     *  returns true, the current row's deactivation event and\r\n     *  callback function will be fired. Otherwise, if this isn't\r\n     *  supplied or it returns false, the currently activated row\r\n     *  will stay activated when the mouse leaves the menu entirely. */\r\n    exitMenu?: EventHandler,\r\n    /** Function to call when a menu row is clicked */\r\n    clickRow?: EventHandler\r\n\r\n    /** Selector for identifying which elements in the menu are rows\r\n     *  that can trigger the above events. Defaults to \"> li\". */\r\n    rowSelector?:string,\r\n    /** You may have some menu rows that aren't submenus and therefore\r\n     *  shouldn't ever need to \"activate.\" If so, filter submenu rows\r\n     *  w/ this selector.\r\n     *  Defaults to \"*\" (all elements).\r\n     */\r\n    submenuSelector?:string,\r\n\r\n    /** Direction the submenu opens relative to the main menu.\r\n     *  This controls which direction is \"forgiving\" as the user\r\n     *  moves their cursor from the main menu into the submenu.\r\n     *  Can be one of \"right\", \"left\", \"above\", or \"below\".\r\n     *  Defaults to \"right\". */\r\n    submenuDirection?:MenuDirection,\r\n\r\n    /** for how long should menu remain displayed after the mouse has left it */\r\n    exitDelay?:number,\r\n    /** bigger = more forgiving when entering submenu */\r\n    tolerance?:number,\r\n\r\n    /** set it to TRUE if the menu is not nested within another menu */\r\n    isRoot?:boolean,\r\n}\r\n\r\nexport {\r\n    Coordinates,\r\n    MenuDirection,\r\n    EventHandler,\r\n    ElementOffset,\r\n    Options\r\n};"],"sourceRoot":""}