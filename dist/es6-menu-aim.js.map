{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///es6-menu-aim.js","webpack:///webpack/bootstrap 572e7d8d90e261db02ed","webpack:///./lib/es6-menu-aim.ts","webpack:///./lib/es6-menu-aim-types.ts"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","writable","key","_createClass","protoProps","staticProps","value","es6_menu_aim_types_1","_mouseLocs","_instanceCounter","MenuAim","menu","opts","activeRow","lastDelayLoc","timeoutId","exitTimeoutID","options","attach","isRoot","addEventListener","mouseleaveMenu","document","_mousemoveDocument","noop","rowSelector","exitDelay","submenuSelector","submenuDirection","MenuDirection","right","tolerance","enter","exit","activate","deactivate","exitMenu","clickRow","mouseenterRow","bind","mouseleaveRow","commitExit","ev","window","clearTimeout","setTimeout","currentTarget","possiblyActivate","row","newRow","delay","activationDelay","activeRowFound","rows","parentElement","querySelectorAll","maxI","offset","_offset","upperLeft","x","left","y","top","upperRight","offsetWidth","lowerLeft","offsetHeight","lowerRight","loc","prevLoc","decreasingCorner","increasingCorner","below","above","decreasingSlope","_calcSlope","increasingSlope","prevDecreasingSlope","prevIncreasingSlope","li","removeEventListener","push","pageX","pageY","shift","a","b","elem","rect","getBoundingClientRect","win","ownerDocument","defaultView","pageYOffset","pageXOffset"],"mappings":"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","file":"es6-menu-aim.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"es6-menu-aim\"] = factory();\n\telse\n\t\troot[\"es6-menu-aim\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"es6-menu-aim\"] = factory();\n\telse\n\t\troot[\"es6-menu-aim\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar es6_menu_aim_types_1 = __webpack_require__(1);\n\nvar MOUSE_LOCS_TRACKED = 3,\n    // number of past mouse locations to track\nDELAY = 300; // ms delay when user appears to be entering submenu\n// all instances of this class should use the same mouse-move event listener\n\nvar _mouseLocs = [],\n    // counting instances ... this is used to detect if\n// `_mousemoveDocument` should be unregistered\n_instanceCounter = 0;\n/**\n * Main class of MenuAim\n */\n\nvar MenuAim =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor function\n   * @param menu root menu HTML element\n   * @param opts (optional) config options (see [Options](#options))\n   */\n  function MenuAim(menu, opts) {\n    _classCallCheck(this, MenuAim);\n\n    this.activeRow = null;\n    this.lastDelayLoc = null;\n    this.timeoutId = null;\n    this.exitTimeoutID = null;\n    this.options = null;\n    this.menu = null;\n    /**\n     * This method is called initially and each time a menu is re-activated\n     */\n\n    this.attach = function (menu) {\n      this.menu = menu;\n\n      if (this.options.isRoot) {\n        // only the ROOT instance should be registering the `menuExit`\n        // event ... all the contained child instances will be hidden by the root instance\n        this.menu.addEventListener('mouseleave', this.mouseleaveMenu);\n      }\n\n      if (++_instanceCounter === 1) {\n        // IF this is the first instance\n        // > register the single mouse move event handler - only one is needed\n        document.addEventListener('mousemove', _mousemoveDocument);\n      }\n    };\n    /**\n     * Dummy function which is used as default value for event listeners\n     */\n\n\n    var noop = function noop() {};\n\n    opts = opts || {}; // setting the default values\n\n    this.options = {\n      rowSelector: opts.rowSelector || \"> li\",\n      exitDelay: opts.exitDelay || null,\n      submenuSelector: opts.submenuSelector || \"*\",\n      submenuDirection: opts.submenuDirection || es6_menu_aim_types_1.MenuDirection.right,\n      tolerance: opts.tolerance || 75,\n      isRoot: opts.isRoot || true,\n      enter: opts.enter || noop,\n      exit: opts.exit || noop,\n      activate: opts.activate || noop,\n      deactivate: opts.deactivate || noop,\n      exitMenu: opts.exitMenu || noop,\n      clickRow: opts.clickRow || noop\n    }; // binding event handlers\n\n    this.mouseenterRow = this.mouseenterRow.bind(this);\n    this.mouseleaveRow = this.mouseleaveRow.bind(this);\n    this.clickRow = this.clickRow.bind(this);\n    this.mouseleaveMenu = this.mouseleaveMenu.bind(this);\n    this.commitExit = this.commitExit.bind(this); // attaching event listeners\n\n    this.attach(menu);\n  }\n  /**\n   * Cancel possible row activations when leaving the menu entirely\n   * @param ev Mouse Event\n   */\n\n\n  _createClass(MenuAim, [{\n    key: \"mouseleaveMenu\",\n    value: function mouseleaveMenu(ev) {\n      if (this.timeoutId) {\n        window.clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n\n      if (this.options.exitDelay) {\n        if (this.exitTimeoutID) {\n          // IF the scheduling timer already exists -> clear it\n          window.clearTimeout(this.exitTimeoutID);\n          this.exitTimeoutID = null;\n        }\n\n        this.exitTimeoutID = window.setTimeout(this.commitExit, this.options.exitDelay);\n      } else {\n        this.commitExit();\n      }\n    }\n    /**\n     * Hides all the sub-menus and the menu. It can be called externally\n     */\n\n  }, {\n    key: \"forceExit\",\n    value: function forceExit() {\n      // clear the exit timeout ... if it's set\n      if (this.exitTimeoutID) {\n        window.clearTimeout(this.exitTimeoutID);\n      }\n\n      this.commitExit();\n    }\n    /**\n     * Closes the menu\n     */\n\n  }, {\n    key: \"commitExit\",\n    value: function commitExit() {\n      this.timeoutId = this.exitTimeoutID = null; // IF exitMenu is supplied and returns true, deactivate the\n      // currently active row on menu exit.\n\n      if (this.options.exitMenu(this)) {\n        if (this.activeRow) {\n          this.options.deactivate(this.activeRow);\n        }\n\n        this.activeRow = null;\n      }\n    }\n    /**\n     * Trigger a possible row activation whenever entering a new row.\n     * @param ev Mouse event\n     */\n\n  }, {\n    key: \"mouseenterRow\",\n    value: function mouseenterRow(ev) {\n      if (this.exitTimeoutID) {\n        // console.log('schedule Exit CLEAR');\n        clearTimeout(this.exitTimeoutID);\n        this.exitTimeoutID = null;\n      }\n\n      if (this.timeoutId) {\n        // Cancel any previous activation delays\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n\n      this.options.enter(ev.currentTarget);\n      this.possiblyActivate(ev.currentTarget);\n    }\n  }, {\n    key: \"mouseleaveRow\",\n    value: function mouseleaveRow(ev) {\n      this.options.exit(ev.currentTarget);\n    }\n    /**\n     * Immediately activate a row if the user clicks on it.\n     * @param ev Mouse Event\n     */\n\n  }, {\n    key: \"clickRow\",\n    value: function clickRow(ev) {\n      if (ev.currentTarget !== this.activeRow) {\n        this.activate(ev.currentTarget);\n      }\n\n      this.options.clickRow(ev, ev.currentTarget); // pozovi registrirani event handler\n    }\n    /**\n     * Activate a menu row.\n     * @param row menu row which should be activated\n     */\n\n  }, {\n    key: \"activate\",\n    value: function activate(row) {\n      if (row == this.activeRow) {\n        return;\n      }\n\n      if (this.activeRow) {\n        this.options.deactivate(this.activeRow);\n      }\n\n      var newRow = this.options.activate(row);\n\n      if (newRow) {\n        this.activeRow = newRow;\n      } else {\n        this.activeRow = row;\n      }\n    }\n    /**\n     * Possibly activate a menu row. If mouse movement indicates that we\n     * shouldn't activate yet because user may be trying to enter\n     * a submenu's content, then delay and check again later.\n     *\n     * @param row menu row to be activated\n     */\n\n  }, {\n    key: \"possiblyActivate\",\n    value: function possiblyActivate(row) {\n      var delay = this.activationDelay();\n      var self = this;\n\n      if (delay) {\n        this.timeoutId = setTimeout(function () {\n          self.possiblyActivate(row);\n        }, delay);\n      } else {\n        this.activate(row);\n      }\n    }\n    /**\n     * Return the amount of time that should be used as a delay before the\n     * currently hovered row is activated.\n     *\n     * Returns 0 if the activation should happen immediately. Otherwise,\n     * returns the number of milliseconds that should be delayed before\n     * checking again to see if the row should be activated.\n     */\n\n  }, {\n    key: \"activationDelay\",\n    value: function activationDelay() {\n      var activeRowFound = false;\n\n      if (this.activeRow) {\n        // IF active row is set\n        // > check to see if it's of correct type\n        var rows = this.activeRow.parentElement.querySelectorAll(this.options.submenuSelector);\n\n        for (var i = 0, maxI = rows.length; i < maxI; i++) {\n          if (rows[i] === this.activeRow) {\n            activeRowFound = true;\n            break;\n          }\n        }\n      }\n\n      if (!activeRowFound) {\n        // IF there is no other submenu row already active, then\n        // go ahead and activate immediately.\n        return 0;\n      }\n\n      var offset = _offset(this.menu),\n          upperLeft = {\n        x: offset.left,\n        y: offset.top - this.options.tolerance\n      },\n          upperRight = {\n        x: offset.left + this.menu.offsetWidth,\n        y: upperLeft.y\n      },\n          lowerLeft = {\n        x: offset.left,\n        y: offset.top + this.menu.offsetHeight + this.options.tolerance\n      },\n          lowerRight = {\n        x: offset.left + this.menu.offsetWidth,\n        y: lowerLeft.y\n      },\n          loc = _mouseLocs[_mouseLocs.length - 1],\n          prevLoc = _mouseLocs[0];\n\n      if (!loc) {\n        return 0;\n      }\n\n      if (!prevLoc) {\n        prevLoc = loc;\n      }\n\n      if (prevLoc.x < offset.left || prevLoc.x > lowerRight.x || prevLoc.y < offset.top || prevLoc.y > lowerRight.y) {\n        // If the previous mouse location was outside of the entire\n        // menu's bounds, immediately activate.\n        return 0;\n      }\n\n      if (this.lastDelayLoc && loc.x == this.lastDelayLoc.x && loc.y == this.lastDelayLoc.y) {\n        // If the mouse hasn't moved since the last time we checked\n        // for activation status, immediately activate.\n        return 0;\n      }\n\n      var decreasingCorner = upperRight,\n          increasingCorner = lowerRight; // Our expectations for decreasing or increasing slope values\n      // depends on which direction the submenu opens relative to the\n      // main menu. By default, if the menu opens on the **right**, we\n      // expect the slope between the cursor and the upper right\n      // corner to decrease over time, as explained above. If the\n      // submenu opens in a different direction, we change our slope\n      // expectations.\n\n      if (this.options.submenuDirection == es6_menu_aim_types_1.MenuDirection.left) {\n        decreasingCorner = lowerLeft;\n        increasingCorner = upperLeft;\n      } else if (this.options.submenuDirection == es6_menu_aim_types_1.MenuDirection.below) {\n        decreasingCorner = lowerRight;\n        increasingCorner = lowerLeft;\n      } else if (this.options.submenuDirection == es6_menu_aim_types_1.MenuDirection.above) {\n        decreasingCorner = upperLeft;\n        increasingCorner = upperRight;\n      }\n\n      var decreasingSlope = _calcSlope(loc, decreasingCorner),\n          increasingSlope = _calcSlope(loc, increasingCorner),\n          prevDecreasingSlope = _calcSlope(prevLoc, decreasingCorner),\n          prevIncreasingSlope = _calcSlope(prevLoc, increasingCorner);\n\n      if (decreasingSlope < prevDecreasingSlope && increasingSlope > prevIncreasingSlope) {\n        // Mouse is moving from previous location towards the\n        // currently activated submenu. Delay before activating a\n        // new menu row, because user may be moving into submenu.\n        this.lastDelayLoc = loc;\n        return DELAY;\n      }\n\n      this.lastDelayLoc = null;\n      return 0;\n    }\n    /**\n     * Hook up menu item events. This method allows menu\n     * items to be added externaly\n     */\n\n  }, {\n    key: \"hookUp\",\n    value: function hookUp(li) {\n      li.addEventListener('mouseenter', this.mouseenterRow);\n      li.addEventListener('mouseleave', this.mouseleaveRow);\n      li.addEventListener('click', this.clickRow);\n    }\n    /**\n     * Sets a DOM node as currently active menu item.\n     * This is to be used form external code in case\n     * menu item list can dynamically change\n     * @param row DOM node to be set active\n     */\n\n  }, {\n    key: \"setActiveRow\",\n    value: function setActiveRow(row) {\n      this.activeRow = row;\n\n      if (this.timeoutId) {\n        // AKO već postoji schedulirani timeout -> resetiraj ga\n        // console.log('schedule Exit CLEAR');\n        window.clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n\n      if (this.exitTimeoutID) {\n        // AKO već postoji schedulirani timeout -> resetiraj ga\n        // console.log('schedule Exit CLEAR');\n        window.clearTimeout(this.exitTimeoutID);\n        this.exitTimeoutID = null;\n      }\n    }\n    /**\n     * Deactivate menu item which is currently marked as active\n     */\n\n  }, {\n    key: \"deactivateRow\",\n    value: function deactivateRow() {\n      if (this.activeRow) {\n        this.options.deactivate(this.activeRow);\n      }\n\n      this.activeRow = null;\n    }\n    /**\n     * Detaches MenuAim from DOM containser ... to be used\n     * while disposing the menu\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      // preventing multiple calls\n      if (!this.menu) {\n        return;\n      }\n\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n      }\n\n      if (--_instanceCounter === 0) {\n        // IF this was the last existing instance of the class\n        // > stop tracking the mouse cusros\n        document.removeEventListener('mousemove', _mousemoveDocument);\n      }\n\n      if (this.options.isRoot) {\n        this.menu.removeEventListener('mouseleave', this.mouseleaveMenu);\n      }\n\n      this.timeoutId = this.lastDelayLoc = this.activeRow = this.menu = null;\n    }\n  }]);\n\n  return MenuAim;\n}();\n\nexports.MenuAim = MenuAim;\n/**\n * Event handler which keep track of the last few locations of the mouse.\n * @param ev mouse event\n * @private\n */\n\nvar _mousemoveDocument = function _mousemoveDocument(ev) {\n  _mouseLocs.push({\n    x: ev.pageX,\n    y: ev.pageY\n  });\n\n  if (_mouseLocs.length > MOUSE_LOCS_TRACKED) {\n    _mouseLocs.shift();\n  }\n};\n/**\n * Detect if the user is moving towards the currently activated\n * submenu.\n * If the mouse is heading relatively clearly towards\n * the content of submenu, we should wait and give the user more\n * time before activating a new row. If the mouse is heading\n * elsewhere, we can immediately activate a new row.\n * We detect this by calculating the slope formed between the\n * current mouse location and the upper/lower right points of\n * the menu. We do the same for the previous mouse location.\n * If the current mouse location's slopes are\n * increasing/decreasing appropriately compared to the\n * previous, we know the user is moving toward the submenu.\n * Note that since the y-axis increases as the cursor moves\n * down the screen, we are looking for the slope between the\n * cursor and the upper right corner to decrease over time, not\n * increase (somewhat counterintuitively).\n * @param a\n * @param b\n * @private\n */\n\n\nvar _calcSlope = function _calcSlope(a, b) {\n  return (b.y - a.y) / (b.x - a.x);\n};\n/**\n * Returns coordinates of the given element relative to the window\n * @param elem DOM element who's coordinates need to be calculated\n * @private\n */\n\n\nvar _offset = function _offset(elem) {\n  var rect = elem.getBoundingClientRect(),\n      win = elem.ownerDocument.defaultView;\n  return {\n    top: rect.top + win.pageYOffset,\n    left: rect.left + win.pageXOffset\n  };\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar MenuDirection;\n\n(function (MenuDirection) {\n  MenuDirection[\"left\"] = \"left\";\n  MenuDirection[\"right\"] = \"right\";\n  MenuDirection[\"below\"] = \"below\";\n  MenuDirection[\"above\"] = \"above\";\n})(MenuDirection || (MenuDirection = {}));\n\nexports.MenuDirection = MenuDirection;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// es6-menu-aim.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 572e7d8d90e261db02ed","import { Coordinates, MenuDirection, EventHandler, Options, ElementOffset } from './es6-menu-aim-types';\r\n\r\nconst MOUSE_LOCS_TRACKED:number = 3,  // number of past mouse locations to track\r\n    DELAY:number = 300;  // ms delay when user appears to be entering submenu\r\n\r\n// all instances of this class should use the same mouse-move event listener\r\nlet _mouseLocs:Array<Coordinates> = [],\r\n    // counting instances ... this is used to detect if\r\n    // `_mousemoveDocument` should be unregistered\r\n    _instanceCounter = 0;\r\n\r\n/**\r\n * Main class of MenuAim\r\n */\r\nclass MenuAim {\r\n\r\n    activeRow:HTMLElement = null;\r\n\r\n    lastDelayLoc:Coordinates = null;\r\n    timeoutId:number = null;\r\n    exitTimeoutID:number = null;\r\n    options:Options = null;\r\n    menu:HTMLElement = null;\r\n\r\n    /**\r\n     * Constructor function\r\n     * @param menu root menu HTML element\r\n     * @param opts (optional) config options (see [Options](#options))\r\n     */\r\n    constructor(menu:HTMLElement, opts?:Options) {\r\n\r\n        /**\r\n         * Dummy function which is used as default value for event listeners\r\n         */\r\n        const noop = () => {};\r\n\r\n        opts = opts || {};\r\n\r\n        // setting the default values\r\n        this.options = {\r\n                rowSelector: opts.rowSelector || \"> li\",\r\n                exitDelay: opts.exitDelay || null,\r\n                submenuSelector: opts.submenuSelector || \"*\",\r\n                submenuDirection: opts.submenuDirection || MenuDirection.right,\r\n                tolerance: opts.tolerance || 75,\r\n                isRoot: opts.isRoot || true,\r\n                enter: opts.enter || noop,\r\n                exit: opts.exit || noop,\r\n                activate: opts.activate || noop,\r\n                deactivate: opts.deactivate || noop,\r\n                exitMenu: opts.exitMenu || noop,\r\n                clickRow: opts.clickRow || noop\r\n            };\r\n\r\n        // binding event handlers\r\n        this.mouseenterRow = this.mouseenterRow.bind(this);\r\n        this.mouseleaveRow = this.mouseleaveRow.bind(this);\r\n        this.clickRow = this.clickRow.bind(this);\r\n        this.mouseleaveMenu = this.mouseleaveMenu.bind(this);\r\n        this.commitExit = this.commitExit.bind(this);\r\n\r\n        // attaching event listeners\r\n        this.attach(menu);\r\n    }\r\n\r\n    /**\r\n     * This method is called initially and each time a menu is re-activated\r\n     */\r\n    attach = function(menu:HTMLElement):void {\r\n\r\n        this.menu = menu;\r\n\r\n        if(this.options.isRoot) {\r\n        // only the ROOT instance should be registering the `menuExit`\r\n        // event ... all the contained child instances will be hidden by the root instance\r\n            this.menu.addEventListener('mouseleave', this.mouseleaveMenu);\r\n        }\r\n\r\n        if(++_instanceCounter===1) {\r\n        // IF this is the first instance\r\n        // > register the single mouse move event handler - only one is needed\r\n            document.addEventListener('mousemove', _mousemoveDocument);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancel possible row activations when leaving the menu entirely\r\n     * @param ev Mouse Event\r\n     */\r\n    mouseleaveMenu(ev:Event):void {\r\n\r\n        if (this.timeoutId) {\r\n            window.clearTimeout(this.timeoutId);\r\n            this.timeoutId = null;\r\n        }\r\n\r\n        if(this.options.exitDelay) {\r\n\r\n            if(this.exitTimeoutID) {\r\n            // IF the scheduling timer already exists -> clear it\r\n\r\n                window.clearTimeout(this.exitTimeoutID);\r\n                this.exitTimeoutID = null;\r\n            }\r\n\r\n            this.exitTimeoutID = window.setTimeout(this.commitExit, this.options.exitDelay);\r\n\r\n        } else {\r\n            this.commitExit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides all the sub-menus and the menu. It can be called externally\r\n     */\r\n    forceExit():void {\r\n\r\n        // clear the exit timeout ... if it's set\r\n        if(this.exitTimeoutID) {\r\n            window.clearTimeout(this.exitTimeoutID);\r\n        }\r\n\r\n        this.commitExit();\r\n\r\n    }\r\n\r\n    /**\r\n     * Closes the menu\r\n     */\r\n    commitExit():void {\r\n\r\n        this.timeoutId = this.exitTimeoutID = null;\r\n\r\n        // IF exitMenu is supplied and returns true, deactivate the\r\n        // currently active row on menu exit.\r\n        if (this.options.exitMenu(this)) {\r\n            if (this.activeRow) {\r\n                this.options.deactivate(this.activeRow);\r\n            }\r\n\r\n            this.activeRow = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger a possible row activation whenever entering a new row.\r\n     * @param ev Mouse event\r\n     */\r\n    mouseenterRow(ev:MouseEvent):void {\r\n\r\n        if(this.exitTimeoutID) {\r\n            // console.log('schedule Exit CLEAR');\r\n            clearTimeout(this.exitTimeoutID);\r\n            this.exitTimeoutID = null;\r\n        }\r\n\r\n        if (this.timeoutId) {\r\n            // Cancel any previous activation delays\r\n            clearTimeout(this.timeoutId);\r\n            this.timeoutId = null;\r\n        }\r\n\r\n        this.options.enter(ev.currentTarget);\r\n\r\n        this.possiblyActivate(<HTMLElement>ev.currentTarget);\r\n    }\r\n\r\n\r\n    mouseleaveRow(ev:MouseEvent):void {\r\n        this.options.exit(ev.currentTarget);\r\n    }\r\n\r\n    /**\r\n     * Immediately activate a row if the user clicks on it.\r\n     * @param ev Mouse Event\r\n     */\r\n    clickRow(ev:MouseEvent):void {\r\n        \r\n        if(ev.currentTarget !== this.activeRow) {\r\n            this.activate(<HTMLElement>ev.currentTarget);\r\n        }\r\n\r\n        this.options.clickRow(ev, ev.currentTarget); // pozovi registrirani event handler\r\n    }\r\n\r\n    /**\r\n     * Activate a menu row.\r\n     * @param row menu row which should be activated\r\n     */\r\n    activate(row:HTMLElement):void {\r\n\r\n        if (row == this.activeRow) {\r\n            return;\r\n        }\r\n\r\n        if (this.activeRow) {\r\n            this.options.deactivate(this.activeRow);\r\n        }\r\n\r\n        var newRow = this.options.activate(row);\r\n\r\n        if(newRow) {\r\n            this.activeRow = newRow;\r\n        } else {\r\n            this.activeRow = row;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Possibly activate a menu row. If mouse movement indicates that we\r\n     * shouldn't activate yet because user may be trying to enter\r\n     * a submenu's content, then delay and check again later.\r\n     * \r\n     * @param row menu row to be activated\r\n     */\r\n    possiblyActivate(row:HTMLElement):void {\r\n\r\n        let delay = this.activationDelay();\r\n        let self = this;\r\n\r\n        if (delay) {\r\n            this.timeoutId = setTimeout(() => {  self.possiblyActivate(row); }, delay);\r\n        } else {\r\n            this.activate(row);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the amount of time that should be used as a delay before the\r\n     * currently hovered row is activated.\r\n     *\r\n     * Returns 0 if the activation should happen immediately. Otherwise,\r\n     * returns the number of milliseconds that should be delayed before\r\n     * checking again to see if the row should be activated.\r\n     */\r\n    activationDelay():number {\r\n\r\n        let activeRowFound:boolean = false;\r\n\r\n        if (this.activeRow) {\r\n        // IF active row is set\r\n        // > check to see if it's of correct type\r\n            let rows:NodeListOf<HTMLElement> = this.activeRow.parentElement.querySelectorAll(this.options.submenuSelector);\r\n    \r\n            for(let i=0,maxI=rows.length; i<maxI; i++) {\r\n                if(rows[i] === this.activeRow) {\r\n                    activeRowFound=true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!activeRowFound) {\r\n        // IF there is no other submenu row already active, then\r\n        // go ahead and activate immediately.\r\n            return 0;\r\n        }\r\n\r\n        var offset = _offset(this.menu),\r\n            upperLeft = {\r\n                x: offset.left,\r\n                y: offset.top - this.options.tolerance\r\n            },\r\n            upperRight = {\r\n                x: offset.left + this.menu.offsetWidth,\r\n                y: upperLeft.y\r\n            },\r\n            lowerLeft = {\r\n                x: offset.left,\r\n                y: offset.top + this.menu.offsetHeight + this.options.tolerance\r\n            },\r\n            lowerRight = {\r\n                x: offset.left + this.menu.offsetWidth,\r\n                y: lowerLeft.y\r\n            },\r\n            loc = _mouseLocs[_mouseLocs.length - 1],\r\n            prevLoc = _mouseLocs[0];\r\n\r\n        if (!loc) {\r\n            return 0;\r\n        }\r\n\r\n        if (!prevLoc) {\r\n            prevLoc = loc;\r\n        }\r\n\r\n        if (prevLoc.x < offset.left || prevLoc.x > lowerRight.x ||\r\n            prevLoc.y < offset.top || prevLoc.y > lowerRight.y) {\r\n            // If the previous mouse location was outside of the entire\r\n            // menu's bounds, immediately activate.\r\n            return 0;\r\n        }\r\n\r\n        if (this.lastDelayLoc &&\r\n                loc.x == this.lastDelayLoc.x && loc.y == this.lastDelayLoc.y) {\r\n            // If the mouse hasn't moved since the last time we checked\r\n            // for activation status, immediately activate.\r\n            return 0;\r\n        }\r\n\r\n        var decreasingCorner = upperRight,\r\n            increasingCorner = lowerRight;\r\n\r\n        // Our expectations for decreasing or increasing slope values\r\n        // depends on which direction the submenu opens relative to the\r\n        // main menu. By default, if the menu opens on the **right**, we\r\n        // expect the slope between the cursor and the upper right\r\n        // corner to decrease over time, as explained above. If the\r\n        // submenu opens in a different direction, we change our slope\r\n        // expectations.\r\n        if (this.options.submenuDirection == MenuDirection.left) {\r\n            decreasingCorner = lowerLeft;\r\n            increasingCorner = upperLeft;\r\n        } else if (this.options.submenuDirection == MenuDirection.below) {\r\n            decreasingCorner = lowerRight;\r\n            increasingCorner = lowerLeft;\r\n        } else if (this.options.submenuDirection == MenuDirection.above) {\r\n            decreasingCorner = upperLeft;\r\n            increasingCorner = upperRight;\r\n        }\r\n\r\n        var decreasingSlope = _calcSlope(loc, decreasingCorner),\r\n            increasingSlope = _calcSlope(loc, increasingCorner),\r\n            prevDecreasingSlope = _calcSlope(prevLoc, decreasingCorner),\r\n            prevIncreasingSlope = _calcSlope(prevLoc, increasingCorner);\r\n\r\n        if (decreasingSlope < prevDecreasingSlope &&\r\n                increasingSlope > prevIncreasingSlope) {\r\n            // Mouse is moving from previous location towards the\r\n            // currently activated submenu. Delay before activating a\r\n            // new menu row, because user may be moving into submenu.\r\n            this.lastDelayLoc = loc;\r\n            return DELAY;\r\n        }\r\n\r\n        this.lastDelayLoc = null;\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Hook up menu item events. This method allows menu\r\n     * items to be added externaly\r\n     */\r\n    hookUp(li:HTMLElement):void {\r\n        li.addEventListener('mouseenter', this.mouseenterRow);\r\n        li.addEventListener('mouseleave', this.mouseleaveRow);\r\n        li.addEventListener('click', this.clickRow);\r\n    }\r\n\r\n    /**\r\n     * Sets a DOM node as currently active menu item.\r\n     * This is to be used form external code in case\r\n     * menu item list can dynamically change\r\n     * @param row DOM node to be set active\r\n     */\r\n    setActiveRow(row:HTMLElement):void {\r\n\r\n        this.activeRow = row;\r\n\r\n        if(this.timeoutId) {\r\n        // AKO već postoji schedulirani timeout -> resetiraj ga\r\n            // console.log('schedule Exit CLEAR');\r\n\r\n            window.clearTimeout(this.timeoutId);\r\n            this.timeoutId = null;\r\n        }\r\n\r\n        if(this.exitTimeoutID) {\r\n        // AKO već postoji schedulirani timeout -> resetiraj ga\r\n            // console.log('schedule Exit CLEAR');\r\n\r\n            window.clearTimeout(this.exitTimeoutID);\r\n            this.exitTimeoutID = null;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Deactivate menu item which is currently marked as active\r\n     */\r\n    deactivateRow():void {\r\n\r\n        if(this.activeRow) {\r\n            this.options.deactivate(this.activeRow);\r\n        }\r\n\r\n        this.activeRow = null;\r\n    }\r\n\r\n    /**\r\n     * Detaches MenuAim from DOM containser ... to be used\r\n     * while disposing the menu\r\n     */\r\n    detach():void {\r\n        // preventing multiple calls\r\n        if(!this.menu) {\r\n            return;\r\n        }\r\n\r\n        if (this.timeoutId) {\r\n            clearTimeout(this.timeoutId);\r\n        }\r\n\r\n        if(--_instanceCounter===0) {\r\n        // IF this was the last existing instance of the class\r\n        // > stop tracking the mouse cusros\r\n            document.removeEventListener('mousemove', _mousemoveDocument);\r\n        }\r\n\r\n        if(this.options.isRoot) {\r\n            this.menu.removeEventListener('mouseleave', this.mouseleaveMenu)\r\n        }\r\n\r\n        this.timeoutId = this.lastDelayLoc = this.activeRow = this.menu = null;\r\n    }\r\n}\r\n\r\n/**\r\n * Event handler which keep track of the last few locations of the mouse.\r\n * @param ev mouse event\r\n * @private\r\n */\r\nconst _mousemoveDocument = (ev:MouseEvent):void => {\r\n    \r\n    _mouseLocs.push({x: ev.pageX, y: ev.pageY});\r\n\r\n    if (_mouseLocs.length > MOUSE_LOCS_TRACKED) {\r\n        _mouseLocs.shift();\r\n    }\r\n}\r\n\r\n/**\r\n * Detect if the user is moving towards the currently activated\r\n * submenu.\r\n * If the mouse is heading relatively clearly towards\r\n * the content of submenu, we should wait and give the user more\r\n * time before activating a new row. If the mouse is heading\r\n * elsewhere, we can immediately activate a new row.\r\n * We detect this by calculating the slope formed between the\r\n * current mouse location and the upper/lower right points of\r\n * the menu. We do the same for the previous mouse location.\r\n * If the current mouse location's slopes are\r\n * increasing/decreasing appropriately compared to the\r\n * previous, we know the user is moving toward the submenu.\r\n * Note that since the y-axis increases as the cursor moves\r\n * down the screen, we are looking for the slope between the\r\n * cursor and the upper right corner to decrease over time, not\r\n * increase (somewhat counterintuitively).\r\n * @param a \r\n * @param b \r\n * @private\r\n */\r\nconst _calcSlope = (a:Coordinates, b:Coordinates):number => {\r\n    return ((b.y - a.y) / (b.x - a.x));\r\n}\r\n\r\n/**\r\n * Returns coordinates of the given element relative to the window\r\n * @param elem DOM element who's coordinates need to be calculated\r\n * @private\r\n */\r\nconst _offset = (elem:HTMLElement):ElementOffset => {\r\n\r\n    let rect:ClientRect = elem.getBoundingClientRect(),\r\n        win:Window = elem.ownerDocument.defaultView;\r\n\r\n    return({\r\n        top: rect.top + win.pageYOffset,\r\n        left: rect.left + win.pageXOffset\r\n    });\r\n}\r\n\r\nexport { Coordinates, EventHandler, Options, MenuAim };\n\n\n// WEBPACK FOOTER //\n// ./lib/es6-menu-aim.ts","type Coordinates = {\r\n    x:number,\r\n    y:number\r\n};\r\n\r\ntype ElementOffset = {\r\n    top:number,\r\n    left:number\r\n};\r\n\r\nenum MenuDirection {\r\n    left = \"left\",\r\n    right = \"right\",\r\n    below = \"below\",\r\n    above = \"above\"\r\n}\r\n\r\ntype EventHandler = (data:any, target?:any) => any;\r\n\r\ntype Options = {\r\n    /** Function to call when a row is purposefully activated.\r\n     *  Use this to show a submenu's content for the activated row.*/ \r\n    activate?: EventHandler,\r\n    /** Function to call when a row is deactivated */\r\n    deactivate?: EventHandler,\r\n    /** Function to call when mouse enters a menu row.\r\n     *  Entering a row does not mean the row has been\r\n     *  activated, as the user may be mousing over to a submenu. */\r\n    enter?: EventHandler,\r\n    /** Function to call when mouse exits a menu row. */\r\n    exit?: EventHandler,\r\n    /** Function to call when mouse exits the entire menu. If this\r\n     *  returns true, the current row's deactivation event and\r\n     *  callback function will be fired. Otherwise, if this isn't\r\n     *  supplied or it returns false, the currently activated row\r\n     *  will stay activated when the mouse leaves the menu entirely. */\r\n    exitMenu?: EventHandler,\r\n    /** Function to call when a menu row is clicked */\r\n    clickRow?: EventHandler\r\n\r\n    /** Selector for identifying which elements in the menu are rows\r\n     *  that can trigger the above events. Defaults to \"> li\". */\r\n    rowSelector?:string,\r\n    /** You may have some menu rows that aren't submenus and therefore\r\n     *  shouldn't ever need to \"activate.\" If so, filter submenu rows\r\n     *  w/ this selector.\r\n     *  Defaults to \"*\" (all elements).\r\n     */\r\n    submenuSelector?:string,\r\n\r\n    /** Direction the submenu opens relative to the main menu.\r\n     *  This controls which direction is \"forgiving\" as the user\r\n     *  moves their cursor from the main menu into the submenu.\r\n     *  Can be one of \"right\", \"left\", \"above\", or \"below\".\r\n     *  Defaults to \"right\". */\r\n    submenuDirection?:MenuDirection,\r\n\r\n    /** for how long should menu remain displayed after the mouse has left it */\r\n    exitDelay?:number,\r\n    /** bigger = more forgiving when entering submenu */\r\n    tolerance?:number,\r\n\r\n    /** set it to TRUE if the menu is not nested within another menu */\r\n    isRoot?:boolean,\r\n}\r\n\r\nexport {\r\n    Coordinates,\r\n    MenuDirection,\r\n    EventHandler,\r\n    ElementOffset,\r\n    Options\r\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/es6-menu-aim-types.ts"],"sourceRoot":""}